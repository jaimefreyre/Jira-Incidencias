# -*- coding: utf-8 -*-
"""JIRA-INFORMES.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xN-_IzjhQbawtyQmVke0E6i0ud6CkI66

*Datos* Historicos Sprint
"""

import requests
from requests.auth import HTTPBasicAuth
from datetime import datetime


# Colores
GREEN = "\033[92m"
RESET = "\033[0m"
RED = "\033[91m"


# Configuración de Jira
fecha_fin = '2024-12-24'
base_url = "https://rubi20.atlassian.net/"
email = "<EMAIL USER>"
api_token = "<TOKEN JIRA USER>"
jql_query = "project = 'CAN' AND type = Bug AND sprint = 400 AND resolutiondate > " + fecha_fin +" ORDER BY created DESC"


# Consultar las tarjetas que coinciden con el JQL
search_url = f"{base_url}/rest/api/3/search"
params = {
    "jql": jql_query,
    "fields": "key",  # Solo necesitamos el identificador de cada tarjeta
    "maxResults": 100  # Ajusta según sea necesario
}
response = requests.get(search_url, params=params, auth=HTTPBasicAuth(email, api_token))

if response.status_code == 200:
    issues = response.json()["issues"]
    for idx, issue in enumerate(issues, start=1):  # Agrega un contador iniciando en 1
        issue_key = issue["key"]
        changelog_url = f"{base_url}/rest/api/3/issue/{issue_key}/changelog"
        changelog_response = requests.get(changelog_url, auth=HTTPBasicAuth(email, api_token))

        print(f"Procesando tarjeta {idx}/{len(issues)}: {issue_key}")  # Mensaje con contador

        if changelog_response.status_code == 200:
            changelog = changelog_response.json()
            print(f"Historial para {issue_key}:")
            for history in changelog.get("values", []):
                for item in history["items"]:
                    if item["field"] == "status":
                      created_history = history['created']
                      created_history = datetime.strptime(created_history, '%Y-%m-%dT%H:%M:%S.%f%z')
                      created_history = created_history.strftime('%Y-%m-%d %H:%M:%S')
                      if item['fromString'] == 'UAT-pruebas de usuario' or item['toString'] == 'UAT-pruebas de usuario':

                        if item['toString'] == 'UAT-pruebas de usuario' and created_history > fecha_fin:
                          print(f"{RED} - {created_history}: {item['fromString']} -> {item['toString']} {RESET}")
                        else:
                          print(f"{GREEN} - {created_history}: {item['fromString']} -> {item['toString']} {RESET}")

                      else:
                        print(f" - {created_history}: {item['fromString']} -> {item['toString']}")
        else:
            print(f"Error obteniendo historial para {issue_key}: {changelog_response.text}")
else:
    print(f"Error consultando las tarjetas: {response.text}")

"""Datos del Sprint con Grafica tarjetas devueltas por QA"""

import requests
from requests.auth import HTTPBasicAuth
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import pandas as pd
from datetime import datetime

# Define los colores
RED = "\033[91m"
GREEN = "\033[92m"
RESET = "\033[0m"

# Configuración de Jira
fecha_fin = '2024-12-23'
base_url = "https://rubi20.atlassian.net/"
email = "<EMAIL USER>"
api_token = "<TOKEN JIRA USER>"
jql_query = "project = 'CAN' AND sprint = 400 AND resolutiondate > " + fecha_fin +" ORDER BY created DESC"
status_to_filter = "Done"

# Para almacenar los datos para la gráfica
dates = []
statuses = []
colors = []  # Lista para almacenar los colores de los puntos


# Consultar las tarjetas que coinciden con el JQL
search_url = f"{base_url}/rest/api/3/search"
params = {
    "jql": jql_query,
    "fields": "key",  # Solo necesitamos el identificador de cada tarjeta
    "maxResults": 100  # Ajusta según sea necesario
}

# Realiza la consulta para las tarjetas
response = requests.get(search_url, params=params, auth=HTTPBasicAuth(email, api_token))

if response.status_code == 200:
    issues = response.json()["issues"]
    for idx, issue in enumerate(issues, start=1):
        issue_key = issue["key"]
        changelog_url = f"{base_url}/rest/api/3/issue/{issue_key}/changelog"
        changelog_response = requests.get(changelog_url, auth=HTTPBasicAuth(email, api_token))

        print(f"Procesando tarjeta {idx}/{len(issues)}: {issue_key}")  # Mensaje con contador

        if changelog_response.status_code == 200:
            changelog = changelog_response.json()
            print(f"Historial para {issue_key}:")

            # Contador para verificar si el estado 'Listas para DEV' se repite dos veces
            repeatListas_count = 0

            for history in changelog.get("values", []):
                for item in history["items"]:

                    if item["field"] == "summary":
                        print(item['fromString'])

                    # if item["field"] == "description":
                    #     print(item['fromString'])

                    if item["field"] == "status":
                        created_history = history['created']
                        created_history = datetime.strptime(created_history, '%Y-%m-%dT%H:%M:%S.%f%z')
                        created_history = created_history.strftime('%Y-%m-%d %H:%M:%S')

                        # Filtra solo los cambios al estado 'Listas para DEV'
                        if item['toString'] == 'Listas para DEV':
                            repeatListas_count += 1

                        # Si el estado es 'Listas para DEV' y se repite dos veces
                        if repeatListas_count == 2:
                            print(f"{GREEN} - {'Se repite el estado Listas para DEV'} {RESET}")
                            print(f"{RED} - {created_history}: {item['fromString']} -> {item['toString']} {RESET}")
                            # Añadir datos para el gráfico y color rojo
                            dates.append(created_history)
                            statuses.append(item['toString'])
                            colors.append('red')  # Color rojo para este punto
                            repeatListas_count = 0  # Reiniciar el contador

                        # Filtra solo los cambios al estado 'Done'
                        if item['toString'] == 'Done':
                            print(f"{GREEN} - {created_history}: {item['fromString']} -> {item['toString']} {RESET}")
                            # Añadir datos para el gráfico y color verde
                            dates.append(created_history)
                            statuses.append(item['toString'])
                            colors.append('green')  # Color verde para este punto

                        # Filtra el estado especificado (status_to_filter)
                        if item['fromString'] == status_to_filter or item['toString'] == status_to_filter:
                            if item['toString'] == status_to_filter and created_history > fecha_fin:
                                print(f"{RED} - {created_history}: {item['fromString']} -> {item['toString']} {RESET}")
                                # Añadir datos para el gráfico y color rojo
                                dates.append(created_history)
                                statuses.append(item['toString'])
                                colors.append('red')  # Color rojo para este punto
                            elif item['toString'] == status_to_filter and created_history < fecha_fin:
                                print(f"{GREEN} - {created_history}: {item['fromString']} -> {item['toString']} {RESET}")
                                # Añadir datos para el gráfico y color verde
                                dates.append(created_history)
                                statuses.append(item['toString'])
                                colors.append('blue')  # Color verde para este punto

                        else:
                            print(f" - {created_history}: {item['fromString']} -> {item['toString']}")
                            # Añadir datos para el gráfico y color neutro (por defecto)
                            # dates.append(created_history)
                            # statuses.append(item['toString'])
                            # colors.append('blue')  # Color azul por defecto
        else:
            print(f"Error obteniendo historial para {issue_key}: {changelog_response.text}")
else:
    print(f"Error consultando las tarjetas: {response.text}")
# Convertir las fechas a formato datetime para la visualización
dates = pd.to_datetime(dates)

# Crear el DataFrame para la gráfica
df = pd.DataFrame({"Fecha": dates, "Estado": statuses, "Color": colors})

# Graficar
plt.figure(figsize=(10, 6))

# Dibujar el gráfico de dispersión (puntos) o línea de tiempo
plt.scatter(df["Fecha"], df["Estado"], color=df["Color"], label="Cambio de estado", alpha=0.7)

# Personalizar el gráfico
plt.gca().xaxis.set_major_locator(mdates.WeekdayLocator())
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
plt.gcf().autofmt_xdate()

# Etiquetas y título
plt.title(f"Historial de estados de las tarjetas del proyecto CAN")
plt.xlabel("Fecha")
plt.ylabel("Estado")

# Mostrar el gráfico
plt.tight_layout()
plt.show()

"""Grafico Dispersion con Referencias"""

pip install adjustText

import requests
from requests.auth import HTTPBasicAuth
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import pandas as pd
from datetime import datetime
from adjustText import adjust_text  # Biblioteca para evitar superposiciones
import numpy as np  # Para el desplazamiento aleatorio (jitter)



# Define los colores
RED = "\033[91m"
GREEN = "\033[92m"
RESET = "\033[0m"

# Variables
sprint_ref = "Sprint 21"
id_sprint = "168"
fecha_fin = '2024-10-22'

fecha_inicio_tarea = ''
fecha_fin_tarea = ''

# Configuración de Jira
base_url = "https://rubi20.atlassian.net/"
email = "<EMAIL USER>"
api_token = "<TOKEN JIRA USER>"
# jql_query = "project = 'CAN' AND sprint = "+ id_sprint +" AND resolutiondate > " + fecha_fin +" ORDER BY created DESC"
jql_query = "project = 'CAN' AND sprint = "+ id_sprint + " ORDER BY created DESC"
status_to_filter = "UAT-pruebas de usuario"
# status_to_filter = "Done"


# Para almacenar los datos para la gráfica
dates = []
statuses = []
colors = []  # Colores para los puntos
summaries = []  # Summaries para las etiquetas

# Consultar las tarjetas que coinciden con el JQL
search_url = f"{base_url}/rest/api/3/search"
params = {
    "jql": jql_query,
    "fields": "key,summary,issuetype",  # Incluye el resumen en la consulta
    "maxResults": 100
}

response = requests.get(search_url, params=params, auth=HTTPBasicAuth(email, api_token))

if response.status_code == 200:
    issues = response.json()["issues"]
    for idx, issue in enumerate(issues, start=1):
        issue_key = issue["key"]
        summary = issue.get("fields", {}).get("summary", "Sin resumen")  # Obtiene el resumen
        issue_type = issue["fields"]["issuetype"]["name"]
        changelog_url = f"{base_url}/rest/api/3/issue/{issue_key}/changelog"
        changelog_response = requests.get(changelog_url, auth=HTTPBasicAuth(email, api_token))

        print(f"Tarjeta {issue_type} : {idx}/{len(issues)}: {issue_key} - {summary}")

        if changelog_response.status_code == 200:
            changelog = changelog_response.json()
            for history in changelog.get("values", []):
                flag_tag_repeat = 0;
                created_history_date_naive = ''
                fecha_fin_date_naive = ''
                for item in history["items"]:
                        if item["field"] == "status":
                            created_history = history['created']
                            created_history = datetime.strptime(created_history, '%Y-%m-%dT%H:%M:%S.%f%z')
                            created_history = created_history.strftime('%Y-%m-%d %H:%M:%S')
                            issue_key_in = issue_key


                        if item['toString'] == 'Listas para DEV':
                           fecha_inicio_tarea = history['created']
                           created_history_date = datetime.strptime(fecha_inicio_tarea, "%Y-%m-%dT%H:%M:%S.%f%z")           # Ajusta el formato si es necesario
                           if(flag_tag_repeat == 0):
                              print(f"{RESET} - Inicio {created_history} {RESET}")
                           else:
                               print(f"{RED} - Inicio {created_history} {RESET}")

                           flag_tag_repeat + 1


                        if item['toString'] == status_to_filter and issue_key_in == issue_key:
                           fecha_fin_tarea = history['created']
                           fecha_fin_tarea = fecha_fin_tarea.split('T')[0]
                           fecha_fin_date = datetime.strptime(fecha_fin_tarea, "%Y-%m-%d")
                           print(f"{RESET} Finalizado {fecha_fin_date_naive} ; Tardo {str((fecha_fin_date_naive - created_history_date_naive).days) } dias {RESET}")

                           if "PRD".lower() in summary.lower():
                             print(f"{GREEN}  true - {issue_type} -  {RESET}")
                           else:
                             print(f"{RED}  false - {issue_type} - {RESET}")

                           created_history_date_naive = created_history_date.replace(tzinfo=None)
                           fecha_fin_date_naive = fecha_fin_date.replace(tzinfo=None)

                        # Comparación: ¿más de 5 días entre las fechas?
                        if item['toString'] == status_to_filter and (fecha_fin_date_naive - created_history_date_naive).days > 5 and issue_type == 'Error' and ("PRD".lower() in summary.lower()):
                            # print(f"{RED} - Creado {created_history}: Finalizado {fecha_fin_date_naive} -> {str((fecha_fin_date_naive - created_history_date_naive).days) } {RESET}")
                            print(f"{GREEN} Inicio {created_history_date_naive} {RESET}")
                            print(f"{GREEN} Finalizado {fecha_fin_date_naive} ; Tardo {str((fecha_fin_date_naive - created_history_date_naive).days) } dias {RESET}")

                            dates.append(created_history)
                            statuses.append(item['toString'])
                            colors.append('green')
                            summaries.append(issue_key + ' '+ item['toString'] + ' ' + issue_type + ' ' + str((fecha_fin_date_naive - created_history_date_naive).days) + ' Dias')  # Añade el resumen

                        if item['toString'] == 'Listas para DEV' and (fecha_fin_date_naive - created_history_date_naive).days > 5 and issue_type == 'Error':
                            dates.append(created_history)
                            statuses.append(item['toString'])
                            colors.append('blue')
                            summaries.append(issue_key + ' '+ item['toString'] + ' ' + issue_type + ' ' + str((fecha_fin_date_naive - created_history_date_naive).days) + ' Dias')  # Añade el resumen


                        # if item['toString'] == 'DESA en curso' and (fecha_fin_date_naive - created_history_date_naive).days > 5  and issue_type == 'Error':
                        #     dates.append(created_history)
                        #     statuses.append(item['toString'])
                        #     colors.append('red')
                        #     summaries.append(issue_key + ' ' + issue_type + ' ' + str((fecha_fin_date_naive - created_history_date_naive).days) + ' Dias')

                        # if item['toString'] == status_to_filter and created_history > fecha_fin:
                        #     dates.append(created_history)
                        #     statuses.append(item['toString'])
                        #     colors.append('black')
                        #     summaries.append(issue_key + ' ' + issue_type)  # Añade el resumen
                        # elif item['toString'] == status_to_filter and created_history < fecha_fin:
                        #     dates.append(created_history)
                        #     statuses.append(item['toString'])
                        #     colors.append('blue')
                        #     summaries.append(issue_key + ' ' + issue_type)
                        # elif item['toString'] == 'Done':
                        #     dates.append(created_history)
                        #     statuses.append(item['toString'])
                        #     colors.append('green')
                        #     summaries.append(issue_key + ' ' + issue_type)
                        # elif item['toString'] == 'DESA en curso':
                        #     dates.append(created_history)
                        #     statuses.append(item['toString'])
                        #     colors.append('yellow')
                        #     summaries.append(issue_key + ' ' + issue_type)
else:
    print(f"Error consultando las tarjetas: {response.text}")
# Convertir las fechas a formato datetime para la visualización
dates = pd.to_datetime(dates)

# Crear un DataFrame
df = pd.DataFrame({"Fecha": dates, "Estado": statuses, "Color": colors, "Resumen": summaries})

# Mapear los estados a índices numéricos
estado_indices = {estado: idx for idx, estado in enumerate(df["Estado"].unique())}
df["Estado_num"] = df["Estado"].map(estado_indices)

# Agregar desplazamiento aleatorio (jitter) a los índices numéricos
jitter = np.random.uniform(-1, 1, len(df))
df["Estado_jitter"] = df["Estado_num"] + jitter
df["Fecha_jitter"] = df["Fecha"] + pd.to_timedelta(jitter, unit="D")


# Agrupar etiquetas si comparten la misma fecha y estado
df["Etiqueta"] = df.groupby(["Fecha", "Estado"])["Resumen"].transform(lambda x: "\n".join(set(x)))

# Eliminar duplicados para no sobreescribir etiquetas
df = df.drop_duplicates(subset=["Fecha", "Estado", "Etiqueta"])

# Graficar
plt.figure(figsize=(12, 8))
scatter = plt.scatter(df["Fecha_jitter"], df["Estado_jitter"], color=df["Color"], alpha=0.7)

# Añadir etiquetas con los summaries agrupados
texts = [
    plt.text(
        row["Fecha_jitter"], row["Estado_jitter"], row["Etiqueta"], fontsize=8, ha="center", color="black"
    )
    for _, row in df.iterrows()
]

# Ajustar las etiquetas para evitar superposición
adjust_text(texts, arrowprops=dict(arrowstyle="->", color="gray", lw=0.5))

# Configurar el formato de la gráfica
plt.gca().xaxis.set_major_locator(mdates.WeekdayLocator())
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter("%Y-%m-%d"))
plt.gcf().autofmt_xdate()

# Convertir fecha_fin a formato datetime
fecha_fin_datetime = pd.to_datetime(fecha_fin)

# Añadir una línea vertical en la fecha especificada
plt.axvline(x=fecha_fin_datetime, color='black', linestyle='--', label='Fecha límite')


plt.title("Historial de estados de las tarjetas del proyecto CAN | " + sprint_ref)
plt.xlabel("Fecha")
plt.ylabel("Estado")
plt.tight_layout()

plt.show()

"""WORD Export"""

pip install python-docx

import requests
from requests.auth import HTTPBasicAuth
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import pandas as pd
from datetime import datetime

# Define los colores
RED = "\033[91m"
GREEN = "\033[92m"
RESET = "\033[0m"

# Configuración de Jira
sprint_ref = "Sprint 17"
fecha_fin = '2024-11-08'
base_url = "https://rubi20.atlassian.net/"
email = "<EMAIL USER>"
api_token = "<TOKEN JIRA USER>"
jql_query = "project = 'CAN' AND sprint = 169 AND resolutiondate > " + fecha_fin +" ORDER BY created DESC"
status_to_filter = "UAT-pruebas de usuario"

# Para almacenar los datos para la gráfica
dates = []
statuses = []
colors = []  # Lista para almacenar los colores de los puntos


# Consultar las tarjetas que coinciden con el JQL
search_url = f"{base_url}/rest/api/3/search"
params = {
    "jql": jql_query,
    "fields": "key",  # Solo necesitamos el identificador de cada tarjeta
    "maxResults": 100  # Ajusta según sea necesario
}

# Realiza la consulta para las tarjetas
response = requests.get(search_url, params=params, auth=HTTPBasicAuth(email, api_token))


from docx import Document
from docx.shared import RGBColor
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT

# Crear un nuevo documento Word
doc = Document()

# Título del documento
doc.add_heading('Historial de Estados de Tarjetas', level=1)

# Iterar sobre las tarjetas y agregar las salidas al documento
if response.status_code == 200:
    issues = response.json()["issues"]
    for idx, issue in enumerate(issues, start=1):
        issue_key = issue["key"]
        changelog_url = f"{base_url}/rest/api/3/issue/{issue_key}/changelog"
        changelog_response = requests.get(changelog_url, auth=HTTPBasicAuth(email, api_token))

        doc.add_heading(f"Tarjeta {idx}/{len(issues)}: {issue_key}", level=2)

        if changelog_response.status_code == 200:
            changelog = changelog_response.json()
            for history in changelog.get("values", []):
                for item in history["items"]:
                    if item["field"] == "status":
                        created_history = history['created']
                        created_history = datetime.strptime(created_history, '%Y-%m-%dT%H:%M:%S.%f%z')
                        created_history = created_history.strftime('%Y-%m-%d %H:%M:%S')

                        # Crear un nuevo párrafo para cada línea
                        paragraph = doc.add_paragraph()

                        if item['toString'] == status_to_filter and created_history > fecha_fin:
                            run = paragraph.add_run(f"{created_history}: {item['fromString']} -> {item['toString']}")
                            run.font.color.rgb = RGBColor(255, 0, 0)  # Rojo
                        elif item['toString'] == status_to_filter and created_history < fecha_fin:
                            run = paragraph.add_run(f"{created_history}: {item['fromString']} -> {item['toString']}")
                            run.font.color.rgb = RGBColor(0, 255, 0)  # Verde
                        elif item['toString'] == 'Done':
                            run = paragraph.add_run(f"{created_history}: {item['fromString']} -> {item['toString']}")
                            run.font.color.rgb = RGBColor(0, 128, 0)  # Verde oscuro
                        else:
                            paragraph.add_run(f"{created_history}: {item['fromString']} -> {item['toString']}")

        else:
            doc.add_paragraph(f"Error obteniendo historial para {issue_key}: {changelog_response.text}")
else:
    doc.add_paragraph(f"Error consultando las tarjetas: {response.text}")

# Guardar el documento Word
doc.save("Historial_de_Estados_Tarjetas " + sprint_ref + '.docx')

print("Documento guardado como 'Historial_de_Estados_Tarjetas.docx'")